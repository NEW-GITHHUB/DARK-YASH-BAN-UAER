//==============================DARK YASH TIKTOK DOWNLOAD COMMAND==============================
const config = require('../config')
//const {readEnv} = require('../lib/database')
const {cmd , commands} = require('../command')
const fs = require('fs')
const axios = require('axios')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')
const moment = require('moment-timezone');
const os = require("os")
const yts = require('yt-search')
const googleTTS = require('google-tts-api');

function convertToStandardYouTubeURL(url) {
const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
const match = url.match(regex);
if (match && match[1]) {
const videoId = match[1];
return `https://www.youtube.com/watch?v=${videoId}`;
 } else {
return url;
}
}
//=============================ttdl scrapper==================================== 
async function tiktokdl(query) {
return new Promise(async (resolve, reject) => {
try {
const encodedParams = new URLSearchParams();
encodedParams.set("url", query);
encodedParams.set("hd", "1");

const response = await axios({
method: "POST",
url: "https://tikwm.com/api/",
headers: {
"Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
Cookie: "current_language=en",
"User-Agent":
"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36",
},
data: encodedParams,
});
const videos = response.data;
resolve(videos);
} catch (error) {
// reply(`${error}`)
}
});
}
//=============================ttdl scrapper==================================== 

const FormData = require('form-data');
const imgbbUrl = 'https://imgbb.com/';
const uploadUrl = 'https://imgbb.com/json';
const maxFileSize = 32 * 1024 * 1024;


//=========================================================================================================================

function generateRandomFilename(length = 8, numberLength = 4) {
const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
let result = '';
for (let i = 0; i < length; i++) {
result += characters.charAt(Math.floor(Math.random() * characters.length));
}
const number = Math.floor(Math.random() * Math.pow(10, numberLength));
return `${result}${number}`;
}

async function fetchAuthToken() {
try {
const response = await axios.get(imgbbUrl);
const html = response.data;

const tokenMatch = html.match(/PF\.obj\.config\.auth_token="([a-f0-9]{40})"/);
if (tokenMatch && tokenMatch[1]) {
return tokenMatch[1];
}

throw new Error('Auth token not found');
} catch (error) {
console.error('Error fetching auth token:', error.message);
throw error;
}
}
//=========================================================================================================================


// =============================Function to upload image buffer==================================
async function imgurlv2(buffer) {
try {

//==============================Check if the buffer exceeds the maximum file size limit==========
if (buffer.length > maxFileSize) {
return { error: 'File size exceeds 32MB limit' };
}

const authToken = await fetchAuthToken();
const formData = new FormData();

//============================= Generate random filename=======================================
const filename = generateRandomFilename(); 

formData.append('source', buffer, { filename: filename });
formData.append('type', 'file');
formData.append('action', 'upload');
formData.append('timestamp', Date.now());
formData.append('auth_token', authToken);

const uploadResponse = await axios.post(uploadUrl, formData, {
headers: {
...formData.getHeaders(),
},
});

if (uploadResponse.data) {
return uploadResponse.data.image.url; 
} else {
return { error: 'Upload failed, no response data' };
}
} catch (error) {
console.error('Error uploading file:', error.message);
return { error: error.message };
}
}

//===========================================================================================================

cmd({
    pattern: "tiktok",
    alias: ["ttwm"],
    desc: "Download tiktok videos",
    category: "download",
    use: '.tiktok3 <tiktok link>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
await conn.sendMessage(from, { react: { text: 'üí•', key: mek.key }})
if (!q) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rc = await conn.sendMessage(from,{text: '*‚ùå Please Give Me A Tiktok Url...*'},{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}
let data = await tiktokdl(q)

let desc = `‚ùç‚öØ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚öØ‚ùç
       *üßß MANI-X-MD TIKTOK DL üßß*
‚ùç‚öØ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚öØ‚ùç

*\`‚û§ Title :\`* ${data.data.title}

*\`‚û§ Profile_Name:\`* ${data.data.author.nickname}

*\`‚û§ Country:\`* ${data.data.region}

‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚î£ üí¨ *Comments:* ${data.data.comment_count}
‚î£ üîÄ *Share:* ${data.data.share_count}
‚î£ üëÄ *Views:* ${data.data.play_count}
‚î£ ‚¨áÔ∏è *Downloads:* ${data.data.download_count}
‚î£ ‚è±Ô∏è *Duration:* ${data.data.duration}
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ

üî¢ *Please reply with the number you want to select:*

*\`[1] Tiktok Video\`*
       1.1 | üéüÔ∏è With-Watermark
       1.2 | üìº No-Watermark
       1.3 | üé´ No-Watermark *[HD]*

*\`[2] Tiktok Audio\`*
       2.1 | üé∂ Audio file
       2.2 | üìÅ Document file
       2.3 | üé§ Voice cut [ptt]

*üñáÔ∏è URL:* ${q}

*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*

`


//==========NON BUTTON MSG SEND==========

const sentMsg = await conn.sendMessage(from,{image:{url:data.data.cover},caption:desc},{quoted:mek});
const messageID = sentMsg.key.id; // Save the message ID for later reference
await conn.sendMessage(from, { react: { text: 'üî¢', key:sentMsg.key }})

// Listen for the user's response
conn.ev.on('messages.upsert', async (messageUpdate) => {
const mek = messageUpdate.messages[0];
if (!mek.message) return;
const messageType = mek.message.conversation || mek.message.extendedTextMessage?.text;
const from = mek.key.remoteJid;
const sender = mek.key.participant || mek.key.remoteJid;


// Check if the message is a reply to the previously sent message
const isReplyToSentMsg = mek.message.extendedTextMessage && mek.message.extendedTextMessage.contextInfo.stanzaId === messageID;

if (isReplyToSentMsg) {
// Handle correct responses (1, 2, 3, or 4)
if (['1.1', '1.2', '1.3', '2.1', '2.2','2.3'].includes(messageType)) {
//React to the (download downloading the fil)
await conn.sendMessage(from, { react: { text: '‚¨áÔ∏è', key: mek.key } });
//React to the upload (sending the file)
setTimeout(async () => {
conn.sendMessage(from, { react: { text: '‚¨ÜÔ∏è', key: mek.key } });
}, 1000);

if (messageType === '1.1') {
// Handle option 2 (Tiktok Video No Watermark)
let wm = await conn.sendMessage(from, { video: { url: data.data.wmplay }, caption: "- WITH-WATERMARK\n\n*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*",}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚úîÔ∏è', key: mek.key }})
await conn.sendMessage(from, { react: { text: 'üé•', key: wm.key }})

} else if (messageType === '1.2') {
// Handle option 4 (Tiktok Video No Watermark as Document)
let nowm = await conn.sendMessage(from, { video: { url: data.data.play }, caption: "- NO-WATERMARK\n\n*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*",}, { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚úîÔ∏è', key: mek.key }})
await conn.sendMessage(from, { react: { text: 'üé•', key: nowm.key }})

} else if (messageType === '1.3') {
// Handle option 4 (Tiktok Video No Watermark as Document)
let hdq = await conn.sendMessage(from, { video: { url: data.data.hdplay }, caption: "- HD-QUALITY\n\n*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*",}, { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚úîÔ∏è', key: mek.key }})
await conn.sendMessage(from, { react: { text: 'üé•', key: hdq.key }})

} else if (messageType === '2.1') {
// Handle option 5 (Tiktok Audio File)
let aud = await conn.sendMessage(from, { audio: { url: data.data.music },mimetype:"audio/mpeg"}, { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚úîÔ∏è', key: mek.key }})
await conn.sendMessage(from, { react: { text: 'üé∂', key: aud.key }})

} else if (messageType === '2.2') {
let doc = await conn.sendMessage(from,{document: {url:data.data.music},mimetype:"audio/mpeg",fileName: data.data.title, caption:"*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*"},{quoted:mek})
await conn.sendMessage(from, { react: { text: '‚úîÔ∏è', key: mek.key }})
await conn.sendMessage(from, { react: { text: 'üé∂', key: doc.key }})

} else if (messageType === '2.3') {
// Handle option 5 (Tiktok Audio File)
let vo = await conn.sendMessage(from, { audio: { url: data.data.music },mimetype:'audio/mpeg', ptt: true }, { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚úîÔ∏è', key: mek.key }})
await conn.sendMessage(from, { react: { text: 'üéôÔ∏è', key: vo.key }})

}
} else {
// React with invalid input
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
// Invalid option
let tt = await conn.sendMessage(from, { text: '*‚ö†Ô∏è Invalid option! Please enter a valid number (1.1-1.3 , 2.1-2.3) ‚ÄºÔ∏è*' }, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùì', key: tt.key } });

}    
}
});
} catch (e) {
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console (e)
}
});
//============================================================= CMD END ============================================================


 
cmd({
    pattern: "trt",
    alias: ['translate'],
    category: "convert",
    filename: __filename,
    desc: "Translate's given text in desired language."

},
async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
if ( isCmd ){
await conn.readMessages([mek.key]);
}
await conn.sendMessage(from, { react: { text: 'üî§', key: mek.key } });

if(!m.quoted && !m.mentionJid) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rc = await conn.sendMessage(from,{text: '*‚ùå Please Give Me A Text...*' },{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}
const { translate } = require('@vitalets/google-translate-api');

let lang = `${q}`;
if(!lang) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rcr = await conn.sendMessage(from,{text:"‚ùå *Please provide a language to translate*"},{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rcr.key }}
return await conn.sendMessage(from, reactionMessage)
}
let text;
if (m.quoted.conversation) {
text = m.quoted.conversation;
} else if (m.quoted.imageMessage && m.quoted.imageMessage.caption) {
text = m.quoted.imageMessage.caption;
} else if (m.quoted.videoMessage && m.quoted.videoMessage.caption) {
text = m.quoted.videoMessage.caption;
} else {
return;  
}

try{

const response = await translate(text, { to: lang });
let sendtrt = await conn.sendMessage(from, { text: `*üî¥ TRANSLATED INTO : ${lang}*\n\nüîµ ${response.text}\n\n*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*` }, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚úÖ', key: sendtrt.key } });
        
} catch (e) {
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
});

//============================================================= CMD END ============================================================

cmd({
    pattern: "cal",
    desc: "...",
    category: "mathtool",
    use: '.cal',
    filename: __filename
}, 

async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
try {
if ( isCmd ){
await conn.readMessages([mek.key]);
}
    
await conn.sendMessage(from, { react: { text: '‚ûï', key: mek.key } });

if(!q) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rc = await conn.sendMessage(from,{text:"‚ùå *Please give me number...*\n\n‚ÄºÔ∏è *EXAMPLE :-*‚ÄºÔ∏è\n\n> *.cal 12+12 : PLUS* \n> *.cal 12-12 : MINUS*\n> *.cal 12√∑12 : DIVIDED*\n> *.cal 12√ó12 : MULTIPLY*"},{quoted:mek})
const reactionMessage = {react: {text: "‚ùó", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}
const math = require('mathjs');
const result = math.evaluate(q);
//reply(`üó£Ô∏è *According to Your Question, The Answer is Given Below*\n\n*\`${q}\`* = *${result}*\n\n‚óè * ô ü·¥Ä·¥Ñ·¥ã Íú∞…™ Ä·¥á ·¥ç·¥Ö  ô è  ú·¥ÖÍú±* ‚óè`);
let sendanswer = await conn.sendMessage(from, { text: `üó£Ô∏è *ACCORDING TO YOUR QUESTION, THE ANSWER IS GIVEN BELOW*\n\n‚úçÔ∏è *\`${q}\`* = *${result}*\n\n*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*` }, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚úÖ', key: sendanswer.key } });

} catch (e) {
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e);
}
});

//============================================================= CMD END ============================================================

cmd({
    pattern: "tdy",
    desc: "Check bot online or no.",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
const currentTime = moment().tz('Asia/Colombo').format('hh:mm:ss A');   
const currentDate = moment().tz('Asia/Colombo').format('YYYY-MM-DD');


function getTimeOfDay() {
const hour = moment().tz('Asia/Colombo').hour();
if (hour >= 0 && hour < 12) {
return 'Good morning üíêüåû';
} else if (hour >= 12 && hour < 15) {
return 'Good Afternoon';
} else if (hour >= 15 && hour < 18) {
return 'Good Evening';
} else if (hour >= 18 && hour < 24) {
return 'Good night! üí§üõåüí§';
}
}
let desc = `‚îè‚îÄ‚ùñ
‚îÇ„Äå ùóõùó∂ üëã „Äç
‚îó‚î¨‚ùñ „Äå *${pushname}* „Äç
   ‚îÇ‚úë
   ‚îÇ‚úë *üåü TODAY DATE & TIME üåü*
   ‚îÇ‚úë ‚¶Å‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å
   ‚îÇ‚úë  *‚ùÑÔ∏è IT'S NOW:*
   ‚îÇ‚úë   ${getTimeOfDay()}
   ‚îÇ‚úë  *‚è∞ NOW TIME :*
   ‚îÇ‚úë   ${currentTime}
   ‚îÇ‚úë  *üìÜ TODAY DATE*
   ‚îÇ‚úë   ${currentDate}
   ‚îó‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îà ‚≥π

*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*`

let df = await conn.sendMessage(from, { image: {url: "https://i.ibb.co/rDrp6VY/aec190ea955165dd.jpg" }, caption: desc }, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ú®', key: df.key } });
//React to the upload (sending the file)
setTimeout(async () => {
conn.sendMessage(from, { react: { text: 'üåù', key: df.key } });
}, 1000);
    
setTimeout(async () => {
conn.sendMessage(from, { react: { text: 'üåº', key: df.key } });
}, 2000);

setTimeout(async () => {
conn.sendMessage(from, { react: { text: 'üíñ', key: df.key } });
}, 3000);

setTimeout(async () => {
conn.sendMessage(from, { react: { text: 'üåª', key: df.key } });
}, 4000);

setTimeout(async () => {
conn.sendMessage(from, { react: { text: 'üåü', key: df.key } });
}, 5000);

setTimeout(async () => {
conn.sendMessage(from, { react: { text: 'üéã', key: df.key } });
}, 6000);

setTimeout(async () => {
conn.sendMessage(from, { react: { text: 'üå©Ô∏è', key: df.key } });
}, 7000);
    
setTimeout(async () => {
conn.sendMessage(from, { react: { text: 'üíê', key: df.key } });
}, 8000);

} catch (e) {
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e);
}
});
//============================================================= CMD END ============================================================

cmd({
    pattern: "fb",
    alias: ["os"],
    desc: "Check bot system info.",
    category: "main",
    use: '.system',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, isCreator, prefix, isMod, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
if (!q && !q.startsWith("https://")) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rc = await conn.sendMessage(from,{text: '*‚ùå Please Give Me A Fb Url...*' },{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}
//fetch data from api  
let data = await fetchJson(`https://www.dark-yasiya-api.site/download/fbdl2?url=${q}`)

let desc = `*‚î†‚îÄ‚ù≤ üßõ MANIYA-X-MDüßõ ‚ù≥‚îÄ‚î®*

    *üß® FB DOWNLOADER üß®*

*üìö \`Title:\`* Facebook Video

üî¢ Please reply the number you want to select

*\`[1] facebook Video üé•\`*
       1.1 | ü™´ SD QUALITY
       1.2 | üîã HD QUALITY

*\`[2] facebook Video Audio üé∂\`*
       2.1 | Audio file üé∂
       2.2 | Document file üìÇ
       2.3 | Voice cut [ptt] üé§

*üñáÔ∏è FB URL:* ${q}

*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*
`

//==========NON BUTTON MSG SEND==========


sentMsg = await conn.sendMessage(from,{text: desc}, { quoted: mek });
const messageID = sentMsg.key.id; // Save the message ID for later reference


// Listen for the user's response
conn.ev.on('messages.upsert', async (messageUpdate) => {
const mek = messageUpdate.messages[0];
if (!mek.message) return;
const messageType = mek.message.conversation || mek.message.extendedTextMessage?.text;
const from = mek.key.remoteJid;
const sender = mek.key.participant || mek.key.remoteJid;

 
// Check if the message is a reply to the previously sent message
const isReplyToSentMsg = mek.message.extendedTextMessage && mek.message.extendedTextMessage.contextInfo.stanzaId === messageID;

if (isReplyToSentMsg) {
// Handle correct responses (1, 2, 3, or 4)
if (['1.1', '1.2'].includes(messageType)) {
//React to the (download downloading the fil)
await conn.sendMessage(from, { react: { text: '‚¨áÔ∏è', key: mek.key } });
//React to the upload (sending the file)
setTimeout(async () => {
conn.sendMessage(from, { react: { text: '‚¨ÜÔ∏è', key: mek.key } });
}, 1000);


if (messageType === '1.1') {
// Handle option 1 (Audio File)
await conn.sendMessage(from, { video: { url: data.result.sdLink}, mimetype: "video/mp4", caption: "*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*"}, { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key } });
//aud send react
await conn.sendMessage(from, { react: { text: 'üéß', key: aud.key }});

} else if (messageType === '1.2') {
// Handle option 2 (Document File)
// React with file upload completes
await conn.sendMessage(from, { video: { url: data.result.hdLink}, mimetype: "video/mp4", caption: "*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*"}, { quoted: mek })

await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key } });
//aud doc react send
await conn.sendMessage(from, { react: { text: 'üé∂', key: doc.key }});
}
} else {
// React with invalid input
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
// Invalid option
let df = await conn.sendMessage(from, { text: '*‚ö†Ô∏è Invalid option! Please enter a valid number (1-4) ‚ÄºÔ∏è*' }, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùì', key: df.key }})
}
}
});
      
} catch (e) {
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e);
}
});
//============================================================= CMD END ============================================================

cmd({
    pattern: "count",
    desc: "count char",
    category: "owner",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
try {
if ( isCmd ){
await conn.readMessages([mek.key]);
}
let targetText = q || (m.quoted && m.quoted.msg) ? m.quoted.msg : null;

if (!targetText) {
await conn.sendMessage(from, { react: { text: '‚ÅâÔ∏è', key: mek.key } });
return await conn.sendMessage(from, { text: '*‚õî Please mention a text message*' }, { quoted: mek });
}

let charCount = targetText.length;
let wordCount = targetText.trim().split(/\s+/).length;
let paragraphCount = targetText.trim().split(/\n+/).length;

const charLimit = 30000;

if (charCount > charLimit) {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
return await conn.sendMessage(from, { text: `‚õî *Message exceeds the character limit of ${charLimit}. Current count: ${charCount}*` }, { quoted: mek });
}

let countMessage = `üîµ *character count: ${charCount}*\nüü¢ *word count: ${wordCount}*\nüü£ *paragraph count: ${paragraphCount}*\n\n*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*`;
let countchar = await conn.sendMessage(from, { text: countMessage }, { quoted: mek });
return await conn.sendMessage(from, { react: { text: '‚úÖ', key: countchar.key } });

} catch (e) {
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e);
}
});
//============================================================= CMD END ============================================================

cmd({
    pattern: "system",
    alias: ["os"],
    desc: "Check bot system info.",
    category: "main",
    use: '.system',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, isCreator, prefix, isMod, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
if(os.hostname().length == 12 ) hostname = 'replit'
else if(os.hostname().length == 36) hostname = 'heroku'
else if(os.hostname().length == 8) hostname = 'koyeb'
else hostname = os.hostname()
let maru =`*‚îè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îì*
*‚îú ‚è∞ \`Uptime :-\`*  ${runtime(process.uptime())}
*‚îú üìü \`Ram usage :-\`* ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${Math.round(require('os').totalmem / 1024 / 1024)}MB
*‚îú ‚öôÔ∏è \`Platform :-\`*  ${os.hostname()}
*‚îú üë®‚Äçüíª \`Owners :-\`* Manthila
*‚îú üß¨ \`Version :-\`* 1.0.0
*‚îó‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îõ*
`

const mass = await conn.sendMessage(from,{image:{url:"https://i.ibb.co/RGWM42yF/0e921613bfc97476.jpg"},caption:maru},{quoted:mek})
await conn.sendMessage(m.chat, {  react: {  text: "üìü",   key: mass.key }})

}catch(e){
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
})
//============================================================= CMD END ============================================================


cmd({
    pattern: "toptt",
    desc: "tado",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
await conn.sendMessage(from, { react: { text: 'üé§', key: mek.key } });

if(!m.quoted && !m.mentionJid) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rc = await conn.sendMessage(from,{text: "*‚ùå Please Give Me a Video or Voice Meassge...*"},{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}

const fileDataMB = "30";

if (mek.message?.extendedTextMessage?.contextInfo?.quotedMessage?.videoMessage?.fileLength) {
const fileLengthBytes = mek.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.fileLength;
const fileLengthMB = fileLengthBytes / (1024 * 1024);

if (fileLengthMB > fileDataMB) return reply(`‚ùå *Cannot fetch videos longer than ${fileDataMB}MB*`);
}
if (mek.message?.extendedTextMessage?.contextInfo?.quotedMessage?.audioMessage?.fileLength) {
const fileLengthBytes = mek.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage.fileLength;
const fileLengthMB = fileLengthBytes / (1024 * 1024);

if (fileLengthMB > fileDataMB) return reply(`‚ùå *Cannot fetch audios longer than ${fileDataMB}MB*`);
}
if (mek.message?.extendedTextMessage?.contextInfo?.quotedMessage?.documentMessage?.fileLength) {
const fileLengthBytes = mek.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage.fileLength;
const fileLengthMB = fileLengthBytes / (1024 * 1024);

if (fileLengthMB > fileDataMB) return reply(`‚ùå *Cannot fetch audios longer than ${fileDataMB}MB*`);
}

if (!(m.quoted.type === "audioMessage" || m.quoted.type === "videoMessage" || m.quoted.type === "documentMessage")) {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
return await conn.sendMessage(from, { text: '‚õî *Cannot convert this message type.*' }, { quoted: mek });
}

if(m.quoted.type === "audioMessage" || m.quoted.type === "videoMessage" || m.quoted.type === "documentMessage") {

var nameJpg = m.id;

const mass = await conn.sendMessage(from, { text: "*‚ôªÔ∏è Converting and Uploading your File...*" }, { quoted: mek });  
let buff = await m.quoted.download(nameJpg)
let fileType = require('file-type');
let type = fileType.fromBuffer(buff);
await fs.promises.writeFile("./" + type.ext, buff);

let sendaudio = await conn.sendMessage(m.chat, { audio: fs.readFileSync("./" + type.ext), mimetype:  'audio/mpeg',ptt: true,fileName: `${m.id}.mp3` },{quoted: mek})
//await conn.sendMessage(m.chat, { delete: mass })
await conn.sendMessage(m.chat, { react: { text: '‚úÖ', key: mass.key } });
await conn.sendMessage(from, { react: { text: 'üéôÔ∏è', key: sendaudio.key } });
}       
}catch(e){
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
});

//============================================================= CMD END ============================================================

cmd({
    pattern: "toaudio",
    desc: "tado",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
await conn.sendMessage(from, { react: { text: 'üé§', key: mek.key } });

if(!m.quoted && !m.mentionJid) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rc = await conn.sendMessage(from,{text: "*‚ùå Please Give Me a Video or Voice Meassge...*"},{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}

const fileDataMB = "30";

if (mek.message?.extendedTextMessage?.contextInfo?.quotedMessage?.videoMessage?.fileLength) {
const fileLengthBytes = mek.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.fileLength;
const fileLengthMB = fileLengthBytes / (1024 * 1024);

if (fileLengthMB > fileDataMB) return reply(`‚ùå *Cannot fetch videos longer than ${fileDataMB}MB*`);
}
if (mek.message?.extendedTextMessage?.contextInfo?.quotedMessage?.audioMessage?.fileLength) {
const fileLengthBytes = mek.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage.fileLength;
const fileLengthMB = fileLengthBytes / (1024 * 1024);

if (fileLengthMB > fileDataMB) return reply(`‚ùå *Cannot fetch audios longer than ${fileDataMB}MB*`);
}
if (mek.message?.extendedTextMessage?.contextInfo?.quotedMessage?.documentMessage?.fileLength) {
const fileLengthBytes = mek.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage.fileLength;
const fileLengthMB = fileLengthBytes / (1024 * 1024);

if (fileLengthMB > fileDataMB) return reply(`‚ùå *Cannot fetch audios longer than ${fileDataMB}MB*`);
}

if (!(m.quoted.type === "audioMessage" || m.quoted.type === "videoMessage" || m.quoted.type === "documentMessage")) {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
return await conn.sendMessage(from, { text: '‚õî *Cannot convert this message type.*' }, { quoted: mek });
}

if(m.quoted.type === "audioMessage" || m.quoted.type === "videoMessage" || m.quoted.type === "documentMessage") {

var nameJpg = m.id;

const mass = await conn.sendMessage(from, { text: "*‚ôªÔ∏è Converting and Uploading your File...*" }, { quoted: mek });  
let buff = await m.quoted.download(nameJpg)
let fileType = require('file-type');
let type = fileType.fromBuffer(buff);
await fs.promises.writeFile("./" + type.ext, buff);

let sendaudio = await conn.sendMessage(m.chat, { audio: fs.readFileSync("./" + type.ext), mimetype:  'audio/mpeg',fileName: `${m.id}.mp3` },{quoted: mek})
await conn.sendMessage(m.chat, { react: { text: '‚úÖ', key: mass.key } });
await conn.sendMessage(from, { react: { text: 'üéôÔ∏è', key: sendaudio.key } });
}       
}catch(e){
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
});

//============================================================= CMD END ============================================================

cmd({
    pattern: "song",
    desc: "tado",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
await conn.sendMessage(from, { react: { text: 'üé∂', key: mek.key } });

if (!q) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rc = await conn.sendMessage(from,{text: '*‚ùå Please give me a text or url that I want to search...*' },{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}

let mm = convertToStandardYouTubeURL(q)	
const search = await yts(mm)
const data = search.videos[0];
const url = data.url

let desc = `*‚î†‚îÄ‚ù≤ üßõ MANI-X-MD üßõ ‚ù≥‚îÄ‚î®*

    *üé∂ SONG DOWNLOADER üé∂*

*‚îè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îì*
‚î† *‚Ñπ \`Title :\`* ${data.title}
‚î† *üë§ \`Author :\`* ${data.author.name}
‚î† *üëÅÔ∏è‚Äçüó®Ô∏è \`Views :\`* ${data.views}
‚î† *üìå \`Ago :\`* ${data.ago}
‚î† *üïò \`Duration :\`* ${data.timestamp}
‚î† *üîó \`Url :\`* ${data.url}
*‚îó‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îõ*

*üî¢ select the audio type from bellow...*

  1 | *Audio File üé∂*
  2 | *Document File üìÅ*
  
 *‚¶Å ·¥Ö·¥Ä Ä·¥ã- è·¥ÄÍú± ú-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*
`

//==========NON BUTTON MSG SEND==========

const sentMsg = await conn.sendMessage(from,{image:{url: data.thumbnail},caption:desc}, { quoted: mek });
const messageID = sentMsg.key.id; // Save the message ID for later reference


// Listen for the user's response
conn.ev.on('messages.upsert', async (messageUpdate) => {
const mek = messageUpdate.messages[0];
if (!mek.message) return;
const messageType = mek.message.conversation || mek.message.extendedTextMessage?.text;
const from = mek.key.remoteJid;
const sender = mek.key.participant || mek.key.remoteJid;

//-------------------------------------------------------------------------------

 
// Check if the message is a reply to the previously sent message
const isReplyToSentMsg = mek.message.extendedTextMessage && mek.message.extendedTextMessage.contextInfo.stanzaId === messageID;

if (isReplyToSentMsg) {
// Handle correct responses (1, 2, 3, or 4)
if (['1', '2'].includes(messageType)) {
//React to the (download downloading the fil)
await conn.sendMessage(from, { react: { text: '‚¨áÔ∏è', key: mek.key } });
//React to the upload (sending the file)
setTimeout(async () => {
conn.sendMessage(from, { react: { text: '‚¨ÜÔ∏è', key: mek.key } });
}, 1000);

//=======================DOWNLOAD AUDIO========================
let dowmn = await fetchJson(`https://api.fgmods.xyz/api/downloader/ytmp4?url=${url}&apikey=fg_99KrrTNJ`) 
//==============================================================

if (messageType === '1') {
// Handle option 1 (Audio File)
let aud = await conn.sendMessage(from,{audio: {url: dowmn.result.dl_url },mimetype:"audio/mpeg"},{quoted:mek});
 // React with file upload completes
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key } });
//aud send react
await conn.sendMessage(from, { react: { text: 'üéß', key: aud.key }});

} else if (messageType === '2') {
// Handle option 2 (Document File)
let doc = await conn.sendMessage(from,{document: {url: dowmn.result.dl_url },mimetype:"audio/mpeg",fileName:data.title + ".mp3",caption:"*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*"},{quoted:mek});
// React with file upload completes
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key } });
//aud doc react send
await conn.sendMessage(from, { react: { text: 'üé∂', key: doc.key }});
}
} else {
// React with invalid input
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
// Invalid option
let df = await conn.sendMessage(from, { text: '*‚ö†Ô∏è Invalid option! Please enter a valid number (1-4) ‚ÄºÔ∏è*' }, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùì', key: df.key }})
}
}
});     

}catch(e){
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
});
//============================================================= CMD END ============================================================

cmd({
    pattern: "tts",
    desc: "google tts",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
await conn.sendMessage(from, { react: { text: 'üéôÔ∏è', key: mek.key } });

if(!q) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rc = await conn.sendMessage(from,{text: "*‚ùå Please Give Me A Text...* " },{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}
const ttsurl = googleTTS.getAudioUrl(q, {
                lang: "si",
                slow: false,
                host: "https://translate.google.com",
            });

let df = await conn.sendMessage(from, { text: `*‚ôªÔ∏è Generating and Uploading your Voice Message...*` }, { quoted: mek });

           let aud = await conn.sendMessage(from, {
                audio: {
                    url: ttsurl,
                },
                mimetype: "audio/mpeg",
                fileName: `.random.tts.mp3.ptt`,
                ptt: true ,
            }, {
                quoted: mek,
            });                            

await conn.sendMessage(from, { react: { text: 'üé§', key: aud.key } });
await conn.sendMessage(from, { react: { text: '‚úÖ', key: df.key } });

}catch(e){
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
});

//============================================================= CMD END ============================================================

cmd({
    pattern: "menu",
    desc: "To get the menu.",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
await conn.sendMessage(from, { react: { text: 'üõçÔ∏è', key: mek.key }});

const currentTime = moment().tz('Asia/Colombo').format('hh:mm:ss A ');   
const currentDate = moment().tz('Asia/Colombo').format('YYYY-MM-DD');


function getTimeOfDay() {
const hour = moment().tz('Asia/Colombo').hour();
if (hour >= 0 && hour < 12) {
return 'Good morning üíêüåû';
} else if (hour >= 12 && hour < 15) {
return 'Good Afternoon';
} else if (hour >= 15 && hour < 18) {
return 'Good Evening';
} else if (hour >= 18 && hour < 24) {
return 'Good night! üí§üõåüí§';
}
}
    
let menumsg = `*üëã ùóõùóòùóüùóüùó¢...${pushname}...*
   
*‚ï≠‚îÄ„Äåüëπ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥ÖÍú± ·¥ò·¥Ä…¥·¥á üüëπ„Äç*
‚îÉ *‚û©‚è∞ …¥·¥è·¥° ·¥õ…™·¥ç·¥á -* ${currentTime}
‚îÉ *‚û©üìÜ …¥·¥è·¥° ·¥Ö·¥Ä·¥õ·¥á -* ${currentDate}
‚îÉ *‚û©‚öôÔ∏è  Ä·¥Ä·¥ç ·¥úÍú±·¥Ä…¢·¥á -* ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${Math.round(require('os').totalmem / 1024 / 1024)}MB 
*‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§*
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§
‚îÉ *‚õµ LIST PANEL*
‚îÉ‚¶Å‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å
‚îú üì•  1 | *DOWNLOAD*
‚îú üîÑ  2 | *CONVERT*
‚îú üë®‚Äçüíª  4 | *OWNER*
‚îú ü™Ä  5 | *GROUP*
‚îú ü´Ö  6 | *MAIN*
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§

*üí• Reply the Number you want to select*
`
let downloadmenu = `*üëã Hellow ${pushname}*...

*‚ï≠‚îÄ„Äåüëπ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥ÖÍú± ·¥ò·¥Ä…¥·¥á üüëπ„Äç*
‚îÉ *‚û©‚öôÔ∏è  Ä·¥ú…¥ ·¥úÍú±·¥Ä…¢·¥á -* ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${Math.round(require('os').totalmem / 1024 / 1024)}MB 
‚îÉ *‚û©‚öôÔ∏è  Ä·¥Ä·¥ç ·¥õ…™·¥ç·¥á -*  ${runtime(process.uptime())} 
*‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§*
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§
‚îÉ *üì• DOWNLOAD MENU*
‚îÉ *‚¶Å‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å*
‚îúüì•  ${config.PREFIX}song
‚îúüì•  ${config.PREFIX}video
‚îúüì•  ${config.PREFIX}fb
‚îúüì•  ${config.PREFIX}tiktok
‚îúüì•  ${config.PREFIX}ig
‚îúüì•  ${config.PREFIX}twitter
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§

*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*
`

let convertmenu = `*üëã Hellow ${pushname}*...  

*‚ï≠‚îÄ„Äåüëπ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥ÖÍú± ·¥ò·¥Ä…¥·¥á üüëπ„Äç*
‚îÉ *‚û©‚öôÔ∏è  Ä·¥ú…¥ ·¥úÍú±·¥Ä…¢·¥á -* ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${Math.round(require('os').totalmem / 1024 / 1024)}MB 
‚îÉ *‚û©‚öôÔ∏è  Ä·¥Ä·¥ç ·¥õ…™·¥ç·¥á -*  ${runtime(process.uptime())} 
*‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§*
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§
‚îÉ *üîÑ CONVERT MENU*
‚îÉ *‚¶Å‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å*
‚îú üîÑ  ${config.PREFIX}img2url
‚îú üîÑ  ${config.PREFIX}sticker
‚îú üîÑ  ${config.PREFIX}surl
‚îú üîÑ  ${config.PREFIX}tts
‚îú üîÑ  ${config.PREFIX}toptt
‚îú üîÑ  ${config.PREFIX}toaudio
‚îú üîÑ  ${config.PREFIX}trt
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§

*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*
`

let ownermenu = `*üëã Hellow ${pushname}*...  

*‚ï≠‚îÄ„Äåüëπ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥ÖÍú± ·¥ò·¥Ä…¥·¥á üüëπ„Äç*
‚îÉ *‚û©‚öôÔ∏è  Ä·¥ú…¥ ·¥úÍú±·¥Ä…¢·¥á -* ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${Math.round(require('os').totalmem / 1024 / 1024)}MB 
‚îÉ *‚û©‚öôÔ∏è  Ä·¥Ä·¥ç ·¥õ…™·¥ç·¥á -*  ${runtime(process.uptime())} 
*‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§*
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§
‚îÉ *üë®‚Äçüíª OWNER MENU*
‚îÉ *‚¶Å‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å*
‚îúüë®‚Äçüíª  ${config.PREFIX}alljid
‚îúüë®‚Äçüíª  ${config.PREFIX}name
‚îúüë®‚Äçüíª  ${config.PREFIX}about 
‚îúüë®‚Äçüíª  ${config.PREFIX}restart
‚îúüë®‚Äçüíª  ${config.PREFIX}boom
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§

*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*
`
let groupmenu = `*üëã Hellow ${pushname}*... 

*‚ï≠‚îÄ„Äåüëπ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥ÖÍú± ·¥ò·¥Ä…¥·¥á üüëπ„Äç*
‚îÉ *‚û©‚öôÔ∏è  Ä·¥ú…¥ ·¥úÍú±·¥Ä…¢·¥á -* ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${Math.round(require('os').totalmem / 1024 / 1024)}MB 
‚îÉ *‚û©‚öôÔ∏è  Ä·¥Ä·¥ç ·¥õ…™·¥ç·¥á -*  ${runtime(process.uptime())} 
*‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§*
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§
‚îÉ *ü™Ä GROUP MENU*
‚îÉ *‚¶Å‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å*
‚îúü™Ä  ${config.PREFIX}mute
‚îúü™Ä  ${config.PREFIX}unmute
‚îúü™Ä  ${config.PREFIX}promote 
‚îúü™Ä  ${config.PREFIX}demote
‚îúü™Ä  ${config.PREFIX}invite
‚îúü™Ä  ${config.PREFIX}kick
‚îúü™Ä  ${config.PREFIX}left
‚îúü™Ä  ${config.PREFIX}kickall
‚îúü™Ä  ${config.PREFIX}gname
‚îúü™Ä  ${config.PREFIX}gdec
‚îúü™Ä  ${config.PREFIX}gdp
‚îúü™Ä  ${config.PREFIX}del
‚îúü™Ä  ${config.PREFIX}automute
‚îúü™Ä  ${config.PREFIX}autounmute
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§

*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*
`
let mainmenu = `*üëã Hellow ${pushname}*... 

*‚ï≠‚îÄ„Äåüëπ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥ÖÍú± ·¥ò·¥Ä…¥·¥á üüëπ„Äç*
‚îÉ *‚û©‚öôÔ∏è  Ä·¥ú…¥ ·¥úÍú±·¥Ä…¢·¥á -* ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${Math.round(require('os').totalmem / 1024 / 1024)}MB 
‚îÉ *‚û©‚öôÔ∏è  Ä·¥Ä·¥ç ·¥õ…™·¥ç·¥á -*  ${runtime(process.uptime())} 
*‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§*
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§
‚îÉ *ü´Ö MAIN MENU*
‚îÉ *‚¶Å‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å*
‚îúü§¥  ${config.PREFIX}alive
‚îúü§¥  ${config.PREFIX}menu
‚îúü§¥  ${config.PREFIX}ping
‚îúü§¥  ${config.PREFIX}system
‚îúü§¥  ${config.PREFIX}list
‚îúü§¥  ${config.PREFIX}today
‚îúü§¥  ${config.PREFIX}jid
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚¶Å‚¶Å‚û§

*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*
`


// Send the initial message and store the message ID

const sentMsg = await conn.sendMessage(from, { image: {url: "https://i.ibb.co/MxN2rD6T/84e5b4138d23d869.jpg"}, caption: menumsg }, { quoted: mek });
const messageID = sentMsg.key.id; // Save the message ID for later reference


// Listen for the user's response
conn.ev.on('messages.upsert', async (messageUpdate) => {
const mek = messageUpdate.messages[0];
if (!mek.message) return;
const messageType = mek.message.conversation || mek.message.extendedTextMessage?.text;
const from = mek.key.remoteJid;
const sender = mek.key.participant || mek.key.remoteJid;


    
// Check if the message is a reply to the previously sent message
const isReplyToSentMsg = mek.message.extendedTextMessage && mek.message.extendedTextMessage.contextInfo.stanzaId === messageID;

if (isReplyToSentMsg) {
// React to the user's reply (the "1" or "2" message)
//await conn.sendMessage(from, { react: { text: 'üÜó', key: mek.key } });

if (messageType === '1') {
// Handle option 1 (Audio File)
await conn.sendMessage(from, { image: {url: "https://i.ibb.co/MxN2rD6T/84e5b4138d23d869.jpg"}, caption: downloadmenu }, { quoted: mek });
} else if (messageType === '2') {
// Handle option 2 (Document File)
await conn.sendMessage(from, { image: {url: "https://i.ibb.co/MxN2rD6T/84e5b4138d23d869.jpg"}, caption: convertmenu }, { quoted: mek });
} else if (messageType === '3') {
await conn.sendMessage(from, { image: {url: "https://i.ibb.co/MxN2rD6T/84e5b4138d23d869.jpg"}, caption: ownermenu }, { quoted: mek });
} else if (messageType === '4') {
await conn.sendMessage(from, { image: {url: "https://i.ibb.co/MxN2rD6T/84e5b4138d23d869.jpg"}, caption:  groupmenu }, { quoted: mek });
} else if (messageType === '5') {
await conn.sendMessage(from, { image: {url: "https://i.ibb.co/MxN2rD6T/84e5b4138d23d869.jpg"}, caption:  mainmenu }, { quoted: mek });

}

// React to the successful completion of the task
}
});

}catch(e){
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
});

            
cmd({
        pattern: "restart",
        desc: "To restart bot",
        category: "owner",
        filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, isMe, command, args, q, isdev, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isCreator, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{ 
if ( isCmd ){
await conn.readMessages([mek.key]);
}
if(!isOwner) {
const rc = await conn.sendMessage(from,{text:"‚õî *THIS IS AN OWNER COMMAND.*"},{quoted:mek})
const reactionMessage = {react: {text: "‚õî", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}

const mass = await conn.sendMessage(from, { text: "üåü ùó¶ùóßùó¢ùó£ùó£ùóúùó°ùóö ùóîùóüùóü ùóôùó®ùó°ùóñùóßùóúùó¢ùó°ùó¶ ùóîùó°ùóó ùó°ùó¢ùó™ ùó†ùóîùó°ùóú-ùó´-ùó†ùóó ùóúùó¶ ùó•ùóòùó¶ùóßùóîùó•ùóßùóúùó°ùóö...‚ôª"}, { quoted: mek });
await conn.sendMessage(m.chat, {  react: {  text: "üîÑ",   key: mass.key }})
const { exec } = require("child_process") 
exec('pm2 restart all')

} catch (e) {
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
})

//============================================================= CMD END ============================================================


cmd({
    pattern: "about",
    desc: "chnange wa acc about",
    category: "owner",
    filename: __filename
},

async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
if ( isCmd ){
await conn.readMessages([mek.key]);
}
if (!isOwner) {
const rce = await conn.sendMessage(from,{text: "*‚õî THIS IS AN OWNER COMMAND*" },{quoted:mek})
const reactionMessage = {react: {text: "‚õî", key: rce.key }}
return await conn.sendMessage(from, reactionMessage)
}

if(!q) {
const rc = await conn.sendMessage(from,{text: "*‚ùå Please Give me a text...*"},{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}
await conn.updateProfileStatus(q)
return reply("*Done ‚úÖ*")
})

//============================================================= CMD END ============================================================


  
cmd({
    pattern: "wame",
    desc: "wame",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
await conn.sendMessage(from, { react: { text: 'ü™Ä', key: mek.key } });

if (!m.quoted) {
await conn.sendMessage(m.key.remoteJid, { react: { text: '‚ùå', key: mek.key } })
const rc = await conn.sendMessage(from,{text:  "*‚ùå Please mention a user*" },{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}

let users = m.mentionedJid ? m.mentionedJid[0].split('@')[0] : m.quoted ? m.quoted.sender.split('@')[0] : q.replace('@')[0]

let df = await conn.sendMessage(from, { text: `*‚ôªÔ∏è Generating and Uploading your Whatsapp Number URL...*` }, { quoted: mek });
let sendanswer = await conn.sendMessage(from, { text: `*üì§ UPLOADED YOUR WA.ME URL*\n\n> *https://wa.me/${users}*\n\n*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*` }, { quoted: mek });

await conn.sendMessage(from, { react: { text: 'üîó', key: sendanswer.key } });
await conn.sendMessage(from, { react: { text: '‚úÖ', key: df.key } });

}catch(e){
let dm = await conn.sendMessage(from, { text: "*üõë MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
});
//============================================================= CMD END ============================================================


cmd({
    pattern: "surl",
    desc: "long url to short url",
    category: "download",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
await conn.sendMessage(from, { react: { text: 'üñáÔ∏è', key: mek.key } });
if(!q) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rc = await conn.sendMessage(from,{text:  "*‚ùå Please Give Me a URL...*" },{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}
if(!q.startsWith("https://")) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rc = await conn.sendMessage(from,{text: "*‚ùå Wrong Not URL*"},{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}
let data = await axios.get(`https://tinyurl.com/api-create.php?url=${q}`);
let senda = await conn.sendMessage(from, { text: `*‚ôªÔ∏è Generating and Uploading your Short URL...*` }, { quoted: mek });
let sendanswer = await conn.sendMessage(from, { text: `*üì§ UPLOADED YOUR SHORT URL*\n\n> *${data.data}*\n\n*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*` }, { quoted: mek });
await conn.sendMessage(from, { react: { text: 'üîó', key: sendanswer.key } });
await conn.sendMessage(from, { react: { text: '‚úÖ', key: senda.key } });

}catch(e){
let dm = await conn.sendMessage(from, { text: "üõë *DARK YASH MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
});

cmd({
    pattern: "tovv",
    desc: "image/video to view once",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
if(m.quoted && m.quoted.type === "imageMessage"){
let cap = m.quoted.imageMessage.caption || q || "*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*"
let data = await m.quoted.download()
const del = await conn.sendMessage(m.chat, { text: `*Converting...*` }, { quoted: mek });
await conn.sendMessage(from, { image: data, caption: cap,viewOnce:true });
return await conn.sendMessage(m.chat, { delete: del });
}else if(m.quoted && m.quoted.type === "videoMessage"){
const del = await conn.sendMessage(m.chat, { text: `*Converting...*` }, { quoted: mek });
let cap = m.quoted.videoMessage.caption || q || "*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*`"
let data = await m.quoted.download()
await conn.sendMessage(from, { video: data, caption: cap,viewOnce:true });	
return await conn.sendMessage(m.chat, { delete: del });
}else if(m.quoted && m.quoted.type === "audioMessage"){
const del = await conn.sendMessage(m.chat, { text: `*Converting...*` }, { quoted: mek });
let data = await m.quoted.download()
conn.sendMessage(from, { audio:  data, mimetype: 'audio/mpeg', ptt: true, viewOnce:true, fileName: `${m.id}.mp3` })
return await conn.sendMessage(m.chat, { delete: del });
}else{
reply("*‚ùå Please give me a  image/video/audio Message...*")
}

}catch(e){
let dm = await conn.sendMessage(from, { text: "üõë *MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
})

cmd({
    pattern: "imgurl",
    desc: "img2url",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if ( isCmd ){
await conn.readMessages([mek.key]);
}
await conn.sendMessage(from, { react: { text: 'üîó', key: mek.key } });
if(!q) {
setTimeout(async () => {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
}, 500);
const rcc = await conn.sendMessage(from,{text:  "*‚ùå Please Give Me Image...*" },{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rcc.key }}
return await conn.sendMessage(from, reactionMessage)
}
if(!m.quoted.imageMessage) {
await conn.sendMessage(m.key.remoteJid, { react: { text: '‚ùå', key: mek.key } })
const rc = await conn.sendMessage(from,{text:  "*‚ùå Please Give Me A Image...*" },{quoted:mek})
const reactionMessage = {react: {text: "‚ùì", key: rc.key }}
return await conn.sendMessage(from, reactionMessage)
}
let dimg = await m.quoted.download()
let url = await imgurlv2(dimg)
let senda = await conn.sendMessage(from, { text: `*‚ôªÔ∏è Generating and Uploading your Image URL...*` }, { quoted: mek });
let sendanswer = await conn.sendMessage(from, { text: `*üì§ UPLOADED YOUR IMAGE URL*\n\n> *${url}*\n\n*‚¶Å ·¥ç·¥Ä…¥…™-x-·¥ç·¥Ö  ô è ·¥ç·¥Ä…¥…™ ‚¶Å*` }, { quoted: mek });

await conn.sendMessage(from, { react: { text: 'üîó', key: sendanswer.key } });
await conn.sendMessage(from, { react: { text: '‚úÖ', key: senda.key } });

}catch(e){
let dm = await conn.sendMessage(from, { text: "üõë *MANI-X-MD ERROR*"}, { quoted: mek });
await conn.sendMessage(from, { react: { text: '‚ùó', key: dm.key } });
console.log(e)
}
});
